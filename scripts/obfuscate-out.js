#!/usr/bin/env node
/**
 * Apply CSS class obfuscation to static export (out folder)
 * Uses the conversion.json generated by next-css-obfuscator
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.join(__dirname, '..');
const outDir = path.join(rootDir, 'out');
const conversionPath = path.join(rootDir, 'css-obfuscator', 'conversion.json');

// Check if conversion.json exists
if (!fs.existsSync(conversionPath)) {
  console.log('[i] No conversion.json found. Run build:prod first.');
  process.exit(0);
}

const conversion = JSON.parse(fs.readFileSync(conversionPath, 'utf-8'));
const selectors = conversion.selectors || {};

// Build replacement map (original class -> obfuscated class)
const classMap = {};
for (const [original, obfuscated] of Object.entries(selectors)) {
  // Remove leading \. and unescape
  const origClass = original.replace(/^\\\./,'').replace(/\\\\/g, '\\');
  const obfClass = obfuscated.replace(/^\\\./,'');
  classMap[origClass] = obfClass;
}

console.log(`[i] Loaded ${Object.keys(classMap).length} class mappings`);

// Process files recursively
function processDirectory(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      processDirectory(fullPath);
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name).toLowerCase();
      if (['.html', '.js', '.css'].includes(ext)) {
        processFile(fullPath, ext);
      }
    }
  }
}

function processFile(filePath, ext) {
  let content = fs.readFileSync(filePath, 'utf-8');
  let modified = false;
  
  if (ext === '.css') {
    // Replace class selectors in CSS
    for (const [orig, obf] of Object.entries(classMap)) {
      const escapedOrig = orig.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const regex = new RegExp(`\\.${escapedOrig}(?=[^a-zA-Z0-9_-]|$)`, 'g');
      const newContent = content.replace(regex, `.${obf}`);
      if (newContent !== content) {
        content = newContent;
        modified = true;
      }
    }
  } else {
    // Replace class names in HTML/JS
    for (const [orig, obf] of Object.entries(classMap)) {
      // Match class="..." or className="..."
      const escapedOrig = orig.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      
      // Pattern for class attributes
      const classAttrRegex = new RegExp(
        `(class(?:Name)?=["'][^"']*?)\\b${escapedOrig}\\b([^"']*?["'])`,
        'g'
      );
      const newContent = content.replace(classAttrRegex, `$1${obf}$2`);
      if (newContent !== content) {
        content = newContent;
        modified = true;
      }
    }
  }
  
  if (modified) {
    fs.writeFileSync(filePath, content);
    console.log(`[OK] Obfuscated: ${path.relative(rootDir, filePath)}`);
  }
}

// Run
if (fs.existsSync(outDir)) {
  console.log('[i] Processing out folder...');
  processDirectory(outDir);
  console.log('[OK] Obfuscation complete');
} else {
  console.log('[i] No out folder found. Run next build first.');
}
